# bot.py

#### Импортируемые Модули, Функции, Константы:
- **asyncio**: Библиотека для написания асинхронного кода.
- **datetime**: Используется для работы с датами и временем.
- **telegram**: Основной пакет для работы с Telegram API.
- **telegram.ext**: Расширения для Telegram API.

#### Конфигурационные данные:
- **API_TOKEN, VIP_USERS, WHITELIST_USERS**: Конфигурационные данные, такие как токен API и списки пользователей с особыми правами.
- **Функции из database.py**: Эти функции обеспечивают взаимодействие с базой данных. Они включают создание и удаление бронирований, получение информации о забронированных местах, восстановление броней и так далее.
- **PLACES**: Список доступных мест для бронирования.

# Функции

## is_authorized
Проверяет, имеет ли пользователь права на доступ к боту.

**Аргументы**:
  - `user_id`: идентификатор пользователя (целое число), которого нужно проверить.

**Логика работы**:
  - Функция проверяет, содержится ли данный `user_id` в одном из двух списков:
    - `VIP_USERS` (список VIP-пользователей)
    - `WHITELIST_USERS` (список пользователей, которым также предоставлен доступ)

**Возвращаемое значение**:
  - `True`, если `user_id` находится в одном из этих списков, что означает, что пользователь имеет разрешение на использование бота.
  - `False`, если пользователя нет в этих списках, что означает отсутствие доступа.

**Пример**:
  - Если пользователь с `user_id = 399899438`, и этот ID есть в списке `VIP_USERS` или `WHITELIST_USERS`, функция вернёт `True`, иначе - `False`.



## notify_users
Отправляет уведомления всем пользователям, находящимся в списках VIP_USERS и WHITELIST_USERS.

**Аргументы**:
  - `context`: объект контекста, предоставляемый Telegram Bot API, который содержит информацию о боте и позволяет взаимодействовать с пользователями.
  - `message`: сообщение, которое нужно отправить (строка).

**Логика работы**:
  - Создается объединенный список пользователей из двух списков: VIP_USERS и WHITELIST_USERS.
  - Для каждого пользователя из этого объединенного списка:
    - Функция пытается отправить сообщение с помощью метода send_message, используя идентификатор чата `user_id`.
    - Если возникает ошибка при отправке сообщения (например, если пользователь недоступен или заблокировал бота), она игнорируется благодаря блоку `except`.
  
Эта функция является асинхронной (async), что означает, что отправка сообщений выполняется неблокирующим образом, и бот может продолжать выполнять другие задачи, не дожидаясь завершения отправки сообщения каждому пользователю.

## start
Обрабатывает команду /start, выполняя инициализацию и предоставляя пользователю доступ к меню бота.

**Аргументы**:
  - `update`: объект Update, содержащий информацию о поступившем сообщении или нажатии кнопки.
  - `context`: объект ContextTypes.DEFAULT_TYPE, предоставляющий контекст выполнения, включая информацию о боте и пользователях.

**Логика работы**:
1. Получение идентификатора пользователя и имени пользователя:
     - Извлекается `user_id` и `username` из объекта `update`, в зависимости от того, пришло сообщение или нажатие кнопки (callback query).
2. Проверка наличия имени пользователя:
     - Если `username` отсутствует, отправляется сообщение с просьбой указать имя пользователя, и функция завершается.
3. Проверка авторизации:
     - Если пользователь не авторизован (не находится в списках VIP или Whitelist), отправляется сообщение об отказе в доступе, и функция завершается.
4. Получение количества перманентных броней:
     - Вызывается функция `get_booked_places_for_button`, чтобы узнать, сколько перманентных броней есть у пользователя.
5. Создание клавиатуры:
     - Формируется клавиатура с кнопками, позволяющими пользователю выбрать действия:
       - Кнопка "Расписание".
       - Если у пользователя меньше 3 перманентных броней, добавляется кнопка "Забронировать перманентно".
       - Кнопка "Забронировать временно".
       - Кнопка "Удалить бронь".
6. Отправка сообщения с клавиатурой:
     - В зависимости от того, пришло сообщение или callback query, отправляется сообщение с предложением выбрать действие, включая созданную клавиатуру.
7. Планирование удаления сообщения:
     - Сообщение, отправленное пользователю, запланировано на удаление через 60 секунд с помощью `context.job_queue.run_once`, а если это был первоначальный запрос от пользователя (в случае с `update.message`), оно будет удалено через 5 секунд.

**Пример**:
  - Когда пользователь вводит команду /start, бот отвечает, проверяет, авторизован ли пользователь, и предоставляет меню для выбора дальнейших действий, таких как бронирование мест или просмотр расписания.

**Обработка ошибок**:
  - Если у пользователя отсутствует имя, он получает соответствующее сообщение.
  - Если пользователь не авторизован, он также получает уведомление об этом.

## delete_message
Предназначена для удаления сообщения, отправленного ботом, через заданный промежуток времени.

**Аргументы**:
  - `context`: объект ContextTypes.DEFAULT_TYPE, который содержит информацию о задаче (job) и контексте выполнения бота.

**Логика работы**:
1. Извлечение данных о задаче:
     - Получает текущую задачу (job) из объекта `context`.
     - Извлекает `chat_id` и `message_id` из данных задачи (job.data), которые передаются при создании задачи.
2. Удаление сообщения:
     - С помощью метода `delete_message` бота происходит попытка удалить сообщение в чате с указанным `chat_id` и `message_id`.
3. Обработка ошибок:
     - Если при удалении сообщения возникает ошибка `BadRequest` (например, если сообщение уже удалено или ID сообщения недействителен), функция просто игнорирует это исключение и завершает выполнение без каких-либо дополнительных действий.

**Пример**:
  - Эта функция может использоваться для удаления сообщений, отправленных ботом, чтобы поддерживать чистоту чата, например, сообщения с выбором действий, которые были отправлены пользователю и должны исчезнуть через некоторое время.

**Использование**:
  - Функция `delete_message` часто вызывается из других частей кода, где требуется удалить сообщения после определенного события, например, после того как пользователь взаимодействует с ботом или после выбора действия в меню.

## info
Предназначена для отправки пользователю информационного сообщения о возможностях и ограничениях бота для бронирования парковочных мест.

**Аргументы**:
  - `update`: объект Update, содержащий информацию о событии, вызвавшем команду (например, сообщение от пользователя).
  - `context`: объект ContextTypes.DEFAULT_TYPE, который предоставляет контекст выполнения, включая доступ к методам бота.

**Логика работы**:
1. **Подготовка текста помощи**:
     Создается многострочная строка `help_text`, содержащая информацию о функциях бота, правилах бронирования, VIP-функциях и необходимости указания имени пользователя (username).
2. **Извлечение информации о сообщении**:
     Извлекается `message_id` и `chat_id` из входящего сообщения, чтобы использовать их для удаления сообщения через заданный промежуток времени.
3. **Запланированное удаление сообщения**:
     С помощью `context.job_queue.run_once` устанавливается задача на удаление сообщения через 5 секунд после его отправки пользователю, передавая в качестве данных идентификатор чата и идентификатор сообщения.
4. **Отправка сообщения**:
     Бот отправляет сообщение с информацией, используя метод `reply_text`. Текст форматируется с использованием HTML-разметки (например, `<b>` для жирного шрифта).

**Пример**:
Функция `info` может быть вызвана пользователем через команду /info, чтобы получить руководство по использованию бота, что поможет новым пользователям понять основные возможности и ограничения.

## schedule
Отвечает за отображение расписания бронирования парковочных мест на ближайшую неделю, начиная с понедельника. Она формирует текстовое сообщение, которое содержит информацию о свободных и занятых местах на каждый день.

**Аргументы**:
- **update**: объект `Update`, содержащий информацию о событии, вызвавшем команду (например, нажатие на кнопку).
- **context**: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий контекст выполнения, включая доступ к методам бота.

**Логика работы**:
1. **Получение расписания**:
   Вызывается функция `get_schedule()`, которая возвращает расписание бронирований на ближайшую неделю.
   
2. **Определение текущей даты**:
   Получается текущая дата с помощью `datetime.date.today()`, чтобы определить, с какого дня начинать расписание. Вычисляется дата ближайшего понедельника.

3. **Определение названий дней**:
   Создается список `russian_days`, содержащий названия дней недели на русском языке.

4. **Формирование ответа**:
   Инициализируется строка `response`, в которой будет храниться текстовое сообщение о расписании. В цикле по 7 дням (от понедельника до воскресенья):
   - Для каждого дня вычисляется дата и имя дня недели.
   - Если дата меньше текущей даты, она увеличивается на одну неделю (чтобы отобразить расписание на следующую неделю).
   - Для каждого места из списка `PLACES` проверяется, занято ли оно, и формируется соответствующее сообщение.
   - Если место свободно, добавляется строка с пометкой "Свободно".
   - Если место занято, используется функция `check_is_permtemp_status`, чтобы определить статус бронирования и имя пользователя, забронировавшего место.

5. **Удаление сообщения**:
   Удаляется предыдущее сообщение с помощью `update.callback_query.message.delete()`.

6. **Отправка сообщения**:
   Отправляется сообщение с расписанием, используя метод `reply_text`, с поддержкой HTML-разметки.

**Пример**:
При вызове функции `schedule`, бот формирует расписание на ближайшую неделю, начиная с текущего понедельника, и отправляет пользователю список свободных и занятых мест.

**Использование**:
Эта функция полезна для пользователей, которые хотят быстро получить информацию о доступных парковочных местах на ближайшие дни, что упрощает процесс бронирования и планирования.


## book
Отвечает за инициацию процесса бронирования парковочного места, позволяя пользователю выбрать день недели для бронирования. Она создает клавиатуру с кнопками для выбора дня и обновляет текущее сообщение в чате.

**Аргументы**:
- **update**: объект `Update`, содержащий информацию о событии, вызвавшем команду (например, нажатие на кнопку).
- **context**: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий контекст выполнения, включая доступ к методам бота.

**Логика работы**:
1. **Определение текущей даты**:
   Получается текущая дата с помощью `datetime.date.today()`. Вычисляется дата ближайшего понедельника, используя `today - datetime.timedelta(days=today.weekday())`.

2. **Создание списка названий дней**:
   Создается список `russian_days`, содержащий названия дней недели на русском языке.

3. **Формирование клавиатуры**:
   Создается клавиатура `keyboard`, состоящая из 7 кнопок (по одной для каждого дня недели). Каждая кнопка имеет текст, соответствующий дню недели, и `callback_data`, которая будет использоваться для обработки нажатия кнопки (например, `choose_day_Понедельник`).

4. **Отправка обновленного сообщения**:
   Метод `edit_message_text` используется для изменения текста текущего сообщения на "Выберите день для бронирования:" и добавления созданной клавиатуры в качестве разметки ответа.

**Пример**:
При вызове функции `book`, бот обновляет сообщение, предлагая пользователю выбрать день для бронирования из списка доступных дней недели.


## temp_book
Инициирует процесс временного бронирования парковочного места, позволяя пользователю выбрать день недели для временной брони. Она очень похожа на функцию `book`, но предназначена для временного бронирования.

**Аргументы**:
- **update**: объект `Update`, содержащий информацию о событии, вызвавшем команду (например, нажатие на кнопку).
- **context**: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий контекст выполнения, включая доступ к методам бота.

**Логика работы**:
1. **Определение текущей даты**:
   Получается текущая дата с помощью `datetime.date.today()`. Вычисляется дата ближайшего понедельника, используя `today - datetime.timedelta(days=today.weekday())`.

2. **Создание списка названий дней**:
   Создается список `russian_days`, содержащий названия дней недели на русском языке.

3. **Формирование клавиатуры**:
   Создается клавиатура `keyboard`, состоящая из 7 кнопок (по одной для каждого дня недели). Каждая кнопка имеет текст, соответствующий дню недели, и `callback_data`, которая будет использоваться для обработки нажатия кнопки (например, `choose_temp_day_Понедельник`).

4. **Отправка обновленного сообщения**:
   Метод `edit_message_text` используется для изменения текста текущего сообщения на "Выберите день для временного бронирования:" и добавления созданной клавиатуры в качестве разметки ответа.

**Пример**:
При вызове функции `temp_book`, бот обновляет сообщение, предлагая пользователю выбрать день для временного бронирования из списка доступных дней недели.

## choose_temp_day
Обрабатывает выбор пользователя, который выбрал день для временного бронирования парковочного места. Она позволяет пользователю выбрать конкретное место на выбранный день.

**Аргументы**:
- **update**: объект `Update`, содержащий информацию о событии, вызвавшем команду (например, нажатие на кнопку).
- **context**: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий контекст выполнения, включая доступ к методам бота и хранению данных пользователя.

**Логика работы**:
1. **Извлечение дня**:
   - Извлекается день, выбранный пользователем, из `callback_data` нажатой кнопки. Это делается с помощью метода `split('_')`, который разбивает строку по символу подчеркивания и возвращает 4-й элемент (индекс 3), содержащий название дня.
   
2. **Сохранение выбранного дня**:
   - Выбранный день сохраняется в `context.user_data` под ключом `'selected_temp_day'`. Это позволяет позже использовать его для завершения процесса бронирования.

3. **Создание клавиатуры**:
   - Создается клавиатура `keyboard`, состоящая из кнопок для каждого места, доступного для временного бронирования. Каждая кнопка содержит текст, соответствующий месту, и `callback_data`, которая будет использоваться для обработки нажатия кнопки (например, `temp_book_Понедельник_13`).

4. **Отправка обновленного сообщения**:
   - Метод `edit_message_text` используется для изменения текста текущего сообщения на "Выберите место для временного бронирования на {day}:" и добавления созданной клавиатуры в качестве разметки ответа.

**Пример**:
Когда пользователь нажимает на день для временного бронирования, функция `choose_temp_day` обновляет сообщение, предлагая пользователю выбрать конкретное место для временного бронирования на этом дне.

**Использование**:
Эта функция улучшает интерактивность бота, позволяя пользователям выбирать место для временного бронирования.


## handle_temp_booking
Обрабатывает процесс временного бронирования парковочного места пользователем. Она включает в себя логику проверки существующих бронирований и создание нового временного бронирования, если это возможно.

**Аргументы**:
- **update**: объект `Update`, содержащий информацию о событии, вызвавшем команду (например, нажатие на кнопку).
- **context**: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий контекст выполнения, включая доступ к методам бота и хранению данных пользователя.

**Логика работы**:
1. **Извлечение данных**:
   - Получает день и место из `callback_data`.
   - Извлекает `user_id` и `username` пользователя, который нажал на кнопку.

2. **Определение даты бронирования**:
   - Вычисляет `reservation_date` для выбранного дня. Если выбранная дата уже прошла, добавляет одну неделю.

3. **Проверка существующих бронирований**:
   - Вызывает функцию `get_permanent_booking_for_day` для проверки, есть ли у пользователя постоянная бронь на этот день.
     - Если постоянная бронь существует, отправляет сообщение о необходимости удалить ее для бронирования нового места и завершает выполнение функции.
   - Вызывает функцию `get_user_temp_booking_for_day` для проверки, есть ли у пользователя временная бронь на этот день.
     - Если временная бронь существует, отправляет сообщение о необходимости ее удаления и завершает выполнение функции.

4. **Проверка доступности места**:
   - Вызывает функцию `get_temp_booked_places` для проверки, забронировано ли место другим пользователем.
     - Если место свободно, создает временное бронирование с помощью функции `create_temp_booking` и отправляет уведомление другим пользователям.
     - Если место занято:
       - Проверяет, является ли пользователь VIP.
         - Если VIP, удаляет временную броню предыдущего владельца и создает новое временное бронирование.
         - Если не VIP, отправляет сообщение о том, что место уже забронировано, и завершает выполнение функции.

5. **Отправка сообщений**:
   - Если бронирование успешно, отправляет сообщение с подтверждением.
   - Если не удалось забронировать, отправляет сообщение о наличии брони.

6. **Удаление сообщений**:
   - Удаляет сообщения через 20 секунд, используя `context.job_queue.run_once`.

**Пример**:
Когда пользователь выбирает место для временного бронирования, функция `handle_temp_booking` проверяет, может ли пользователь забронировать это место, и выполняет соответствующие действия, включая отправку уведомлений.

**Использование**:
Эта функция управляет процессом временного бронирования, гарантируя, что пользователь не сможет забронировать место, если у него уже есть действующая бронь, а также обеспечивает возможность VIP-пользователям управлять бронированиями других пользователей.

## choose_day
Позволяет пользователю выбрать конкретный день для бронирования парковочного места, после того как он уже выбрал день из списка.

**Аргументы**:
- **update**: объект Update, содержащий информацию о событии (например, нажатие на кнопку).
- **context**: объект ContextTypes.DEFAULT_TYPE, предоставляющий доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы**:
1. **Извлечение дня**:
   Извлекает выбранный день из callback_data, получая значение из строки после `book_`.
   
2. **Сохранение выбранного дня**:
   Сохраняет выбранный день в `user_data`, чтобы использовать его позже в процессе бронирования.
   
3. **Создание клавиатуры для мест**:
   Создает клавиатуру, где каждая кнопка соответствует парковочному месту. Каждая кнопка имеет `callback_data` в формате `book_{day}_{place}`, чтобы идентифицировать, какое место выбрано для бронирования на выбранный день.

4. **Редактирование сообщения**:
   Изменяет текст сообщения, чтобы отобразить пользователю новый выбор с запросом о выборе места для бронирования.

**Пример**:
Когда пользователь выбирает день, например, "Понедельник", функция `choose_day` создает интерфейс для выбора места на этот день, предоставляя кнопки с номерами мест, доступных для бронирования.

**Использование**:
Эта функция является частью процесса бронирования, позволяя пользователям последовательно выбирать день и место.


## remove
Предназначена для того, чтобы помочь пользователям выбрать день, для которого они хотят удалить свою бронь парковочного места.

**Аргументы**:
- **update**: объект Update, содержащий информацию о событии (например, нажатие на кнопку).
- **context**: объект ContextTypes.DEFAULT_TYPE, предоставляющий доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы**:
1. **Определение текущей даты**:
   Получает текущую дату с помощью `datetime.date.today()`. Находит ближайший понедельник, вычитая количество дней, прошедших с начала недели.

2. **Создание массива с днями недели**:
   Определяет список русских названий дней недели от понедельника до воскресенья.

3. **Создание клавиатуры для выбора дня**:
   Генерирует клавиатуру с кнопками, где каждая кнопка соответствует дню недели. Каждая кнопка содержит `callback_data` в формате `choose_remove_day_{day}`, чтобы идентифицировать, какой день выбран для удаления брони.

4. **Редактирование сообщения**:
   Изменяет текст сообщения, отображая пользователю запрос о выборе дня для удаления брони, с соответствующей клавиатурой.

**Пример**:
Когда пользователь инициирует процесс удаления брони, эта функция показывает пользователю список дней недели, чтобы он мог выбрать конкретный день, для которого он хочет удалить свою бронь.

**Использование**:
Функция `remove` является частью интерфейса управления бронями, позволяя пользователям легко находить и удалять свои брони.


## choose_remove_day
Позволяет пользователям выбрать место, для которого они хотят удалить бронь на определенный день.

**Аргументы**:
- **update**: объект Update, который содержит информацию о событии, произошедшем в боте (например, нажатие на кнопку).
- **context**: объект ContextTypes.DEFAULT_TYPE, который предоставляет доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы**:
1. **Извлечение выбранного дня**:
   Получает информацию о выбранном дне из `callback_query.data`, используя метод `split('_')` для разделения данных. Это позволяет извлечь значение `day`, соответствующее выбранному дню для удаления брони.

2. **Сохранение выбранного дня**:
   Сохраняет выбранный день в `context.user_data['remove_day']`, чтобы его можно было использовать в дальнейших функциях (например, при подтверждении удаления).

3. **Создание клавиатуры для выбора места**:
   Генерирует клавиатуру с кнопками для каждого доступного места (PLACES). Каждая кнопка содержит `callback_data` в формате `remove_{day}_{place}`, что позволяет идентифицировать, какое место выбрано для удаления брони на конкретный день.

4. **Редактирование сообщения**:
   Изменяет текст сообщения, отображая пользователю запрос о выборе места для удаления брони на выбранный день, с соответствующей клавиатурой.

**Пример**:
Когда пользователь выбирает день для удаления брони, эта функция показывает список мест, для которых можно удалить бронь, и позволяет пользователю легко выбрать конкретное место.

**Использование**:
Функция `choose_remove_day` предоставляет пользователям удобный интерфейс для управления их бронями, позволяя быстро и легко выбирать место для удаления брони на определенный день.

## handle_booking
Отвечает за обработку запросов на бронирование места пользователем в боте.

**Аргументы:**
- `update`: объект `Update`, который содержит информацию о событии, произошедшем в боте (например, нажатие на кнопку).
- `context`: объект `ContextTypes.DEFAULT_TYPE`, который предоставляет доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы:**
1. **Извлечение данных:**
   - Разделяет `callback_query.data`, чтобы получить выбранный день (`day`) и место (`place`), а также идентификатор (`user_id`) и имя пользователя (`username`).

2. **Проверка постоянной брони:**
   - Проверяет, есть ли у пользователя постоянная бронь на выбранный день с помощью функции `get_permanent_booking_for_day`.
   - Если есть, отправляет сообщение с информацией о забронированном месте и инструкцией по удалению текущей брони.

3. **Проверка временной брони:**
   - Аналогично проверяет наличие временной брони с помощью `get_user_temp_booking_for_day`.
   - Если есть, отправляет сообщение с информацией о временном бронировании и инструкцией по его удалению.

4. **Проверка доступности места:**
   - Проверяет, занято ли выбранное место, с помощью функции `get_booked_places`.
   - Если место уже забронировано, но пользователь является VIP (из списка `VIP_USERS`), то:
     - Удаляет текущее бронирование с помощью `delete_booking`.
     - Создает новое бронирование для VIP-пользователя с помощью `create_booking`.
     - Уведомляет всех пользователей о том, что VIP-пользователь забронировал место, ранее занятое другим пользователем.

5. **Создание нового бронирования:**
   - Если место свободно, создает новое бронирование для обычного пользователя.
   - Уведомляет всех пользователей о новом бронировании.

6. **Отправка сообщения об ошибке:**
   - Если место занято и пользователь не является VIP, отправляет сообщение о том, что место уже забронировано, и удаляет его через 20 секунд.

7. **Успешное бронирование:**
   - Если бронь была успешно создана, удаляет предыдущее сообщение и отправляет сообщение об успешном бронировании, которое также будет удалено через 20 секунд.

**Пример:**
Эта функция используется в контексте бота, когда пользователь выбирает место для бронирования. Она обеспечивает необходимую проверку существующих броней, управляет конфликтами и уведомляет пользователей о результате операции.


## handle_removal
Отвечает за обработку запросов на удаление бронирования места пользователем в боте.

**Аргументы:**
- `update`: объект `Update`, который содержит информацию о событии, произошедшем в боте (например, нажатие на кнопку).
- `context`: объект `ContextTypes.DEFAULT_TYPE`, который предоставляет доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы:**
1. **Извлечение данных:**
   - Получает идентификатор пользователя (`user_id`), имя пользователя (`username`), день удаления (`day`) и место (`place`), выбранное пользователем.

2. **Проверка существующего бронирования:**
   - Вызывает `get_booked_places`, чтобы проверить, кто забронировал место на указанный день.
   - Вызывает `get_temp_booked_info`, чтобы получить информацию о временных бронированиях для данного места и дня.

3. **Обработка для VIP-пользователей:**
   - Если пользователь является VIP (находится в списке `VIP_USERS`), проверяет, если:
     - Существует оригинальный пользователь (`original_user`) для временного бронирования.
     - Пользователь, который временно забронировал место, совпадает с текущим (`temp_user == username`), и оригинальный пользователь не совпадает с текущим.
   - Если условия выполнены, восстанавливает оригинальное бронирование с помощью `restore_bookings_manually`.
   - Затем удаляет бронь с помощью `remove_booking` и уведомляет всех пользователей о том, что VIP удалил бронь.

4. **Обработка для обычных пользователей:**
   - Если текущий пользователь является владельцем бронирования (`booked_user == username`), удаляет бронь, вызывая `remove_booking`.
   - Если есть временное бронирование, отправляет соответствующее сообщение о том, что бронь удалена.
   - Уведомляет всех пользователей о том, что пользователь удалил свою бронь.

5. **Обработка ошибок:**
   - Если текущий пользователь не может удалить бронь (например, если место забронировано другим пользователем), отправляет сообщение об ошибке и уведомляет о конфликте.

6. **Удаление сообщений:**
   - Удаляет предыдущее сообщение об удалении брони через 20 секунд с помощью `context.job_queue.run_once(delete_message, ...)`.

7. **Удаление текущего сообщения:**
   - Удаляет сообщение, в котором пользователь выбрал опцию удаления бронирования.

**Пример:**
Эта функция используется в контексте бота, когда пользователь пытается удалить свое бронирование. Она учитывает права VIP-пользователей и обеспечивает необходимую проверку существующих броней, управляет конфликтами и уведомляет пользователей о результате операции.

## button_handler
Обрабатывает события нажатия кнопок в боте и направляет управление к соответствующим функциям в зависимости от нажатой кнопки.

- **Аргументы**:
  - `update`: объект `Update`, содержащий информацию о событии.
  - `context`: объект `ContextTypes.DEFAULT_TYPE`, предоставляющий доступ к контексту выполнения и хранилищу данных пользователя.

**Логика работы**:
1. **Получение данных запроса**:
   - Извлекает объект `callback_query` из `update`, который содержит информацию о нажатой кнопке.
2. **Обработка нажатий кнопок**:
   - В зависимости от значения `query.data` вызывает соответствующую асинхронную функцию:
     - Если пользователь нажал кнопку 'schedule', вызывается функция `schedule`.
     - Если кнопка 'book', вызывается функция `book`.
     - Если нажата кнопка, начинающаяся с 'choose_day_', вызывается функция `choose_day`.
     - Если кнопка 'remove', вызывается функция `remove`.
     - Если нажата кнопка, начинающаяся с 'choose_remove_day_', вызывается функция `choose_remove_day`.
     - Если кнопка, начинающаяся с 'book_', вызывается функция `handle_booking`.
     - Если кнопка, начинающаяся с 'remove_', вызывается функция `handle_removal`.
     - Если кнопка 'temp_book', вызывается функция `temp_book`.
     - Если нажата кнопка, начинающаяся с 'choose_temp_day_', вызывается функция `choose_temp_day`.
     - Если кнопка, начинающаяся с 'temp_book_', вызывается функция `handle_temp_booking`.

**Пример**:
Эта функция используется в качестве основного обработчика для всех действий, которые могут совершать пользователи в боте.

## main
Отвечает за инициализацию базы данных, настройку обработчиков команд и запуск бота.

**Логика работы**:
1. **Инициализация базы данных**:
   - `init_db()`: инициализирует соединение с базой данных.
   - `create_temp_bookings_table()`: создает таблицу для временных бронирований.
   - `restore_bookings()`: выполняет восстановление или загрузку существующих бронирований из базы данных, если это необходимо.
2. **Создание приложения**:
   - `application = Application.builder().token(API_TOKEN).build()`: создает экземпляр бота с использованием токена API, который должен быть безопасно сохранен.
3. **Добавление обработчиков**:
   - `application.add_handler(CommandHandler("start", start))`: добавляет обработчик для команды /start, который запускает функцию `start`.
   - `application.add_handler(CommandHandler("info", info))`: добавляет обработчик для команды /info, который запускает функцию `info`.
   - `application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex('^/start$') & ~filters.Regex('^/info$'), lambda update, context: update.message.delete()))`: добавляет обработчик, который удаляет текстовые сообщения, если они не являются командами.
   - `application.add_handler(CallbackQueryHandler(button_handler))`: добавляет обработчик для нажатий на кнопки, который вызывает функцию `button_handler`.
4. **Запуск бота**:
   - `application.run_polling()`: запускает опрос, позволяя боту постоянно слушать входящие сообщения и взаимодействия.
