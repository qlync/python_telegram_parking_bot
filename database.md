# database.py

## init_db
Инициализирует базу данных для хранения информации о бронированиях. Она создает таблицу, если она еще не существует.

### Логика работы:
1. **Соединение с базой данных**:  
   Используется `sqlite3.connect('database.db')` для создания соединения с базой данных. Если файл базы данных не существует, он будет создан.
   
2. **Создание курсора**:  
   `cursor = connection.cursor()` создает объект курсора, который позволяет выполнять SQL-запросы к базе данных.
   
3. **Создание таблицы**:  
   `cursor.execute` выполняет SQL-запрос для создания таблицы `bookings`, если она еще не существует. Структура таблицы включает:
   - `id`: Уникальный идентификатор записи (тип INTEGER, автоматически увеличивается).
   - `place`: Название места, где было сделано бронирование (тип TEXT, обязательный).
   - `user`: Имя пользователя, который сделал бронирование (тип TEXT, обязательный).
   - `day`: День бронирования (тип TEXT, обязательный).
   - `is_temp`: Флаг для обозначения, является ли бронирование временным (тип BOOLEAN, по умолчанию FALSE).
   - `manually_deleted`: Флаг для обозначения, было ли бронирование удалено вручную (тип BOOLEAN, по умолчанию 0).

4. **Подтверждение изменений**:  
   `connection.commit()` сохраняет изменения в базе данных.

5. **Закрытие соединения**:  
   `connection.close()` закрывает соединение с базой данных, освобождая ресурсы.


## create_temp_bookings_table
Создает таблицу для хранения временных бронирований. Эта таблица позволяет управлять временными записями о бронировании мест.

### Логика работы:
1. **Соединение с базой данных**:  
   Используется `sqlite3.connect('database.db')` для создания соединения с базой данных. Если файл базы данных не существует, он будет создан.

2. **Создание курсора**:  
   `cursor = connection.cursor()` создает объект курсора, который позволяет выполнять SQL-запросы к базе данных.

3. **Создание таблицы**:  
   `cursor.execute` выполняет SQL-запрос для создания таблицы `temp_bookings`, если она еще не существует. Структура таблицы включает:
   - `id`: Уникальный идентификатор записи (тип INTEGER, автоматически увеличивается).
   - `place`: Название места, где было сделано временное бронирование (тип TEXT, обязательный).
   - `user`: Имя пользователя, который сделал временное бронирование (тип TEXT, обязательный).
   - `day`: День временного бронирования (тип TEXT, обязательный).
   - `original_user`: Имя пользователя, которому принадлежит перманентная бронь (тип TEXT, может быть пустым).
   - `reservation_date`: Дата временного бронирования (тип DATE, обязательный).
   - `restore_date`: Дата, когда временная бронь будет восстановлена (тип DATE, обязательный).

4. **Подтверждение изменений**:  
   `connection.commit()` сохраняет изменения в базе данных.

5. **Закрытие соединения**:  
   `connection.close()` закрывает соединение с базой данных, освобождая ресурсы.

## get_permanent_booking_for_day
Предназначена для получения информации о перманентном бронировании места для указанного пользователя и дня.

**Параметры**:
- `username` (строка): Имя пользователя, для которого требуется получить информацию о перманентном бронировании.
- `day` (строка): День, для которого нужно проверить наличие перманентной брони.

**Возвращаемое значение**:
Возвращает словарь с ключом "place", содержащим название места, если перманентная бронь найдена. Если бронирование не найдено или возникла ошибка, возвращает None.

**Логика работы**:
1. **Соединение с базой данных**:  
   Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Настройка курсора**:  
   `conn.row_factory = sqlite3.Row` позволяет обращаться к результатам запроса как к словарям, что упрощает доступ к полям.

3. **Создание курсора**:  
   `cursor = conn.cursor()` создает объект курсора для выполнения SQL-запросов к базе данных.

4. **Формирование и выполнение запроса**:  
   SQL-запрос выбирает `place` из таблицы `bookings`, где `user` совпадает с переданным именем пользователя, `day` совпадает с переданным днем, и `is_temp` равно 0 (что указывает на перманентную бронь). Выполняется запрос с использованием `cursor.execute`, параметры передаются как кортеж.

5. **Обработка результата**:  
   `result = cursor.fetchone()` извлекает первую строку результата. Если такая строка существует, возвращается словарь с местом. Если строки нет, возвращается None.

6. **Обработка ошибок**:  
   В случае ошибки при выполнении запроса, выводится сообщение об ошибке, и возвращается None.

7. **Закрытие курсора и соединения**:  
   В блоке `finally` закрываются курсор и соединение, освобождая ресурсы.


## get_user_temp_booking_for_day
Предназначена для получения информации о временной броне места для указанного пользователя и дня.

**Параметры**:
- `username` (строка): Имя пользователя, для которого требуется получить информацию о временной броне.
- `day` (строка): День, для которого нужно проверить наличие временной брони.

**Возвращаемое значение**:
Возвращает словарь с ключом "place", содержащим название места, если временная бронь найдена. Если бронь не найдена или возникла ошибка, возвращает None.

**Логика работы**:
1. **Соединение с базой данных**:
   - Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Настройка курсора**:  
   - `conn.row_factory = sqlite3.Row` позволяет обращаться к результатам запроса как к словарям, что упрощает доступ к полям.

3. **Создание курсора**: 
   - `cursor = conn.cursor()` создает объект курсора для выполнения SQL-запросов к базе данных.

4. **Формирование и выполнение запроса**:
   - SQL-запрос выбирает `place` из таблицы `bookings`, где `user` совпадает с переданным именем пользователя, `day` совпадает с переданным днем, и `is_temp` равно 1 (что указывает на временную бронь). 
   - Выполняется запрос с использованием `cursor.execute`, параметры передаются как кортеж.

5. **Обработка результата**:
   - `result = cursor.fetchone()` извлекает первую строку результата. Если такая строка существует, возвращается словарь с местом. Если строки нет, возвращается None.

6. **Обработка ошибок**: 
   - В случае ошибки при выполнении запроса, выводится сообщение об ошибке, и возвращается None.

7. **Закрытие курсора и соединения**:   
   - В блоке `finally` закрываются курсор и соединение, освобождая ресурсы.

## create_booking
Предназначена для создания новой брони места для пользователя в указанную дату.

**Параметры**:
- `place` (строка): Название места, которое необходимо забронировать.
- `user` (строка): Имя пользователя, который создает бронь.
- `day` (строка): День, на который создается бронь.

**Возвращаемое значение**:
Функция ничего не возвращает. Успешное выполнение функции создает запись в таблице `bookings`.

**Логика работы**:
1. **Проверка пользователя**: 
   - Если `user` пустой, вызывается исключение `ValueError` с сообщением "User cannot be empty." для предотвращения создания брони без указания пользователя.

2. **Попытки создания брони**:  
   - Функция пытается выполнить вставку записи в таблицу `bookings` до 5 раз в случае возникновения ошибок, связанных с блокировкой базы данных.

3. **Создание соединения с базой данных**:  
   - Используется `sqlite3.connect('database.db')` для подключения к базе данных.

4. **Создание курсора**: 
   - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

5. **Выполнение запроса**: 
   - SQL-запрос `INSERT INTO bookings (place, user, day, is_temp) VALUES (?, ?, ?, ?)` вставляет новую запись с указанием места, пользователя, дня и значением `is_temp`, установленным в False (что указывает на перманентную бронь).

6. **Коммит изменений**:  
   - `connection.commit()` фиксирует изменения в базе данных.

7. **Закрытие соединения**:  
   - `connection.close()` закрывает соединение с базой данных после успешного выполнения запроса.

8. **Обработка ошибок**: 
   - Если возникает ошибка `sqlite3.OperationalError`, и сообщение об ошибке указывает на блокировку, выполнение запроса повторяется до 5 раз. В противном случае выбрасывается исключение с сообщением об ошибке.

## remove_booking
Удаляет бронь для указанного места и пользователя.

**Параметры**:
- `place` (строка): Название места, для которого нужно удалить бронь.
- `user` (строка): Имя пользователя, у которого нужно удалить бронь.

**Возвращаемое значение**:
Возвращает True, если бронь была успешно удалена. Если брони не существует или возникла ошибка, возвращает False.

**Логика работы**:
1. **Создание соединения с базой данных**:  
   - Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Создание курсора**:  
   - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Выполнение запроса**:  
   - SQL-запрос `DELETE FROM bookings WHERE place = ? AND user = ?` удаляет запись из таблицы `bookings`, соответствующую переданному месту и пользователю.

4. **Подсчет затронутых строк**:  
   - `rows_deleted = cursor.rowcount` получает количество удаленных строк, чтобы определить, была ли успешно удалена бронь.

5. **Коммит изменений**:  
   - `connection.commit()` фиксирует изменения в базе данных.

6. **Закрытие соединения**:  
   - `connection.close()` закрывает соединение с базой данных.

7. **Обработка ошибок**:  
   - В случае ошибки при выполнении запроса, возвращается False.

## remove_temp_booking
Удаляет временную бронь для указанного места и пользователя.

**Параметры**:
- `place` (строка): Название места, для которого нужно удалить временную бронь.
- `user` (строка): Имя пользователя, у которого нужно удалить временную бронь.

**Возвращаемое значение**:
Возвращает True, если временная бронь была успешно удалена. Если временной брони не существует или возникла ошибка, возвращает False.

**Логика работы**:
1. **Создание соединения с базой данных**:  
   - Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Создание курсора**:  
   - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Выполнение запроса**:  
   - SQL-запрос `DELETE FROM temp_bookings WHERE place = ? AND user = ?` удаляет запись из таблицы `temp_bookings`, соответствующую переданному месту и пользователю.

4. **Подсчет затронутых строк**:  
   - `rows_deleted = cursor.rowcount` получает количество удаленных строк, чтобы определить, была ли успешно удалена временная бронь.

5. **Коммит изменений**:  
   - `connection.commit()` фиксирует изменения в базе данных.

6. **Закрытие соединения**:  
   - `connection.close()` закрывает соединение с базой данных.

7. **Обработка ошибок**:  
   - В случае ошибки при выполнении запроса, возвращается False.

## get_temp_booking_info
Получает информацию о временной броне для указанного пользователя и дня.

**Параметры**:
- `username` (строка): Имя пользователя, для которого требуется получить информацию о временной броне.
- `day` (строка): День, для которого нужно проверить наличие временной брони.

**Возвращаемое значение**:
Возвращает кортеж из трех элементов:
- `user` (строка): Имя пользователя, который сделал временную броню.
- `original_user` (строка или None): Имя пользователя, которому принадлежит перманентная бронь (может быть пустым).
- `status` (bool): Статус наличия временной брони (True, если временная бронь найдена, иначе False).

**Логика работы**:
1. **Создание соединения с базой данных**:  
   - Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Создание курсора**:  
   - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Формирование и выполнение запроса**:  
   - SQL-запрос выбирает `user`, `original_user` из таблицы `temp_bookings`, где `place` совпадает с переданным местом, а `day` совпадает с переданным днем. 
   - Выполняется запрос с использованием `cursor.execute`, параметры передаются как кортеж.

4. **Обработка результата**:  
   - `result = cursor.fetchone()` извлекает первую строку результата. Если такая строка существует, возвращается кортеж с именем пользователя, которому принадлежит временная броня, именем пользователя, которому принадлежит перманентная броня, и True (если временная броня найдена). Если строки нет, возвращается кортеж с None и False.

5. **Закрытие курсора и соединения**:  
   - В блоке `finally` закрываются курсор и соединение, освобождая ресурсы.

## restore_bookings
Восстанавливает временные брони для указанного места и дня.

**Параметры**:
- `place` (строка): Название места, для которого нужно восстановить временные брони.
- `day` (строка): День, для которого нужно восстановить временные брони.
- `original_user` (строка): Имя пользователя, которому принадлежит перманентная бронь.

**Возвращаемое значение**:
Функция ничего не возвращает. Успешное выполнение функции восстанавливает временные записи в таблице `bookings`.

**Логика работы**:
1. **Создание соединения с базой данных**:  
   - Используется `sqlite3.connect('database.db')` для создания соединения с базой данных.

2. **Создание курсора**:  
   - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Выполнение запроса**:  
   - SQL-запрос `INSERT INTO bookings (place, user, day, is_temp) VALUES (?, ?, ?, ?)` восстанавливает запись с указанием места, оригинального пользователя, дня и значением `is_temp`, установленным в False (что указывает на перманентную бронь).

4. **Коммит изменений**:  
   - `connection.commit()` фиксирует изменения в базе данных.

5. **Закрытие соединения**:  
   - `connection.close()` закрывает соединение с базой данных.

6. **Обработка ошибок**:  
   - Если возникает ошибка при выполнении запроса, выбрасывается исключение с сообщением об ошибке.

## get_schedule
Предназначена для получения расписания всех бронирований из базы данных, формируя его в удобный для использования словарь.

**Возвращаемое значение**:
-  `schedule` (словарь): Словарь, где ключами являются дни (строки), а значениями - другие словари, которые содержат пары место-пользователь.

**Логика работы**:
1. **Создание соединения с базой данных**:
    - `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.

2. Создание курсора:
    - `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Выполнение SQL-запроса**:
    - `cursor.execute("SELECT day, place, user FROM bookings")` выполняет SQL-запрос, который извлекает все записи из таблицы bookings, выбирая только столбцы day, place и user.

4. **Получение всех строк**:
    - `rows = cursor.fetchall()` извлекает все результаты запроса в виде списка кортежей.

5. **Закрытие соединения**:
    - `connection.close()` закрывает соединение с базой данных, освобождая ресурсы.

6. **Формирование расписания**:
    - Создается пустой словарь schedule.
    - В цикле for day, place, user in rows: происходит обход всех записей, возвращенных из базы данных:
        - Если текущий день (day) не присутствует в schedule, создается новый пустой словарь для этого дня.
        - Записывается информация о месте и пользователе: schedule[day][place] = user.

7. **Возврат расписания**:
    - Функция возвращает сформированный словарь schedule, который содержит информацию о всех бронированиях по дням.

## get_booked_places
Предназначена для получения пользователя, который забронировал указанное место на определенный день.

**Параметры**:
- `place` (строка): Название места, для которого необходимо проверить бронирование.
- `day` (строка): День, для которого нужно проверить бронирование.

**Возвращаемое значение**:
- `user` (строка или None): Возвращает имя пользователя (строка), если место забронировано на указанный день, или None, если место свободно.

**Логика работы**:
1. **Создание соединения с базой данных**:
    - `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.

2. **Создание курсора**:
	- `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Выполнение SQL-запроса**:
	- `cursor.execute("SELECT user FROM bookings WHERE place = ? AND day = ?", (place, day))` выполняет SQL-запрос, который выбирает имя пользователя из таблицы bookings для указанного места и дня.

4. **Получение результата**:
	- `result = cursor.fetchone()` извлекает первую строку результата запроса.

5. **Закрытие соединения**:
	- `connection.close()` закрывает соединение с базой данных.

6. **Возврат имени пользователя**:
	- `return result[0] if result else None` возвращает имя пользователя, если запись найдена (то есть, если результат не None), иначе возвращает None.

## get_booked_places_for_button
Предназначена для получения количества перманентных бронирований для заданного пользователя.

**Параметры**:
- `username` (строка): Имя пользователя, для которого необходимо узнать количество перманентных бронирований.

**Возвращаемое значение**:
- `count` (целое число): Возвращает кол-во перманентных бронирований, связанных с указанным пользователем. Если у пользователя нет перманентных бронирований, возвращается 0.

**Логика работы**:
1. Создание соединения с базой данных:
	`connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.

2. Создание курсора:
	`cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. Выполнение SQL-запроса:
	`cursor.execute("SELECT COUNT(*) FROM bookings WHERE user = ? AND is_temp = 0", (username,))` выполняет SQL-запрос, который считает количество записей в таблице bookings, где user соответствует указанному пользователю и is_temp равно 0 (то есть, только перманентные бронирования).

4. Получение результата:
	`count = cursor.fetchone()[0]` извлекает первое значение из результата запроса, которое представляет собой количество перманентных бронирований.

5. Закрытие соединения:
	`connection.close()` закрывает соединение с базой данных.

6. Возврат количества бронирований:
	`return count` возвращает полученное количество перманентных бронирований.

## create_temp_booking
Предназначена для создания временного бронирования на указанное место и дату, а также для обработки возможных перманентных броней на то же место.

**Параметры**:
- `place` (строка): Название или идентификатор парковочного места, которое бронируется.
- `user` (строка): Имя пользователя, который делает временное бронирование.
- `reservation_date` (строка): Дата, когда было сделано временное бронирование.
- `restore_date` (строка): Дата, когда временное бронирование будет восстановлено.
- `day` (строка): День, на который производится бронирование.

**Логика работы**:
1. Создание соединения с базой данных:
	`connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.

2. Создание курсора:
	`cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. Проверка наличия перманентной брони:
	`cursor.execute("SELECT user FROM bookings WHERE place = ? AND day = ? AND is_temp = ?", (place, day, False))` выполняет запрос для проверки, существует ли перманентное бронирование на данное место и день.
	`result = cursor.fetchone()` извлекает результат выполнения запроса.

4. Обработка перманентной брони:
	Если перманентная бронь существует (в result есть данные):
	Извлекается имя original_user, который владеет перманентным бронированием.
	cursor.execute(...) добавляет новую запись о временной броне в таблицу temp_bookings, включая информацию о original_user.
	Удаляется перманентная бронь: cursor.execute("DELETE FROM bookings WHERE place = ? AND day = ? AND is_temp = ?", (place, day, False)).

5. Создание временной брони:
	Если перманентной брони нет:
	Вставляется новая запись в таблицу temp_bookings с указанными параметрами.

6. Обновление таблицы bookings:
	`cursor.execute("INSERT OR REPLACE INTO bookings (place, user, day, is_temp) VALUES (?, ?, ?, ?)", (place, user, day, True))` обновляет или добавляет запись о временной броне в таблице bookings.

7. Сохранение изменений:
	`connection.commit()` фиксирует изменения в базе данных.

8. Закрытие соединения:
	`connection.close()` закрывает соединение с базой данных.

## restore_bookings
Восстанавливает перманентные бронирования из временных броней, которые истекли (то есть, для которых прошла дата восстановления), и очищает соответствующие записи в таблице временных броней.

**Логика работы**:
1. **Получение текущей даты**:
    - `today = datetime.date.today()`получает сегодняшнюю дату, используемую для сравнения с датами восстановления временных броней.

2. **Создание соединения с базой данных**:
	- `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.

3. **Создание курсора**:
	- `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

4. **Извлечение истекших временных броней**:
	- `cursor.execute("SELECT place, day, original_user FROM temp_bookings WHERE restore_date < ?", (today,))` извлекает места, дни и оригинальных пользователей для 	временных броней, у которых дата восстановления меньше сегодняшней даты.
	- `rows = cursor.fetchall()` извлекает все результаты выполнения запроса.

5. **Обработка каждой истекшей временной брони**:
	- Цикл `for row in rows:` проходит по всем извлеченным записям.
	- `place, day, original_user = row` распаковывает данные о каждом месте, дне и пользователе.

6. **Восстановление перманентной брони**:
	- Выводится сообщение о восстановлении брони: 
        - `print(f"Restoring booking for {place} on {day} by {original_user}.")`.
	- Если original_user существует, выполняется запрос для проверки, была ли перманентная бронь вручную удалена:
	    - `cursor.execute("SELECT manually_deleted FROM bookings WHERE place = ? AND day = ? AND user = ?", (place, day,original_user))`
	- Если результат запроса показывает, что перманентная бронь была удалена (первый элемент в result равен 1), выводится сообщение и восстановление не происходит.
	- Если перманентная бронь не была удалена, выполняется вставка или замена записи о перманентной брони:
	    - `cursor.execute("INSERT OR REPLACE INTO bookings (place, user, day, is_temp) VALUES (?, ?, ?, ?)", (place, original_user, day, False))`

7. **Удаление временной брони**:
    - Удаляются временные записи из таблицы bookings для указанного места и дня:
	    - `cursor.execute("DELETE FROM bookings WHERE place = ? AND day = ? AND is_temp = 1", (place, day))`

8. **Удаление записи из временной таблицы**:
	- Удаляется соответствующая запись из таблицы temp_bookings:
	    - `cursor.execute("DELETE FROM temp_bookings WHERE place = ? AND day = ?", (place, day))`

9. **Очистка старых временных броней**:
	- В конце, удаляются все временные записи из temp_bookings, которые уже были восстановлены:
	    - `cursor.execute("DELETE FROM temp_bookings WHERE restore_date < ?", (today,))`

10. **Сохранение изменений**:
	- `connection.commit()` фиксирует изменения в базе данных.

11. **Закрытие соединения**:
	- `connection.close()` закрывает соединение с базой данных.

## restore_bookings_manually
Восстанавливает перманентную бронь для пользователя, если она была временно заменена, и удаляет временную бронь из базы данных.

**Логика работы**:
1. **Вывод информации**:
	- Сначала выводится сообщение о том, что функция была вызвана для указанного места и дня:
		- `print(f"restore_bookings_manually called for place {place} on day {day}")`

2. **Создание соединения с базой данных**:
	- `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.
	- `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

3. **Получение оригинального пользователя**:
	- `cursor.execute("SELECT original_user FROM temp_bookings WHERE place = ? AND day = ?", (place, day))`
	- `result = cursor.fetchone()` получает результат запроса.

4. **Проверка наличия оригинального пользователя**:
	- Если результат существует и содержит оригинального пользователя, выполняется дальнейшая обработка:
		- `if result and result[0]:`
    	- `original_user = result[0]`

5. **Проверка на наличие ручного удаления**:
	- Выполняется запрос для проверки, была ли перманентная бронь для оригинального пользователя вручную удалена:
		- `cursor.execute("SELECT manually_deleted FROM bookings WHERE place = ? AND day = ? AND user = ?", (place, day, original_user))`
		- `result_manual = cursor.fetchone()` получает результат этого запроса.

6. **Восстановление перманентной брони**:
	- Если перманентная бронь была удалена вручную, выводится сообщение, и восстановление не происходит:
		- `if result_manual and result_manual[0]:`
    	- `print(f"Permanent booking for {original_user} was manually deleted. Not restoring.")`
	- Если перманентная бронь не была удалена, выполняется вставка или замена записи о перманентной броне:
		- `cursor.execute("INSERT OR REPLACE INTO bookings (place, user, day, is_temp) VALUES (?, ?, ?, ?)", (place, original_user, day, False))`
		- `print(f"Booking for {original_user} on {place} for {day} has been restored.")`

7. **Удаление временной брони**:
	- Удаляется временная запись из таблицы temp_bookings для указанного места и дня:
		- `cursor.execute("DELETE FROM temp_bookings WHERE place = ? AND day = ?", (place, day))`
		- `print(f"Temporary booking on {place} for {day} has been removed.")`

8. **Сохранение изменений**:
	- `connection.commit()` фиксирует изменения в базе данных.

9. **Закрытие соединения**:
	- `connection.close()` закрывает соединение с базой данных.

## get_temp_booked_info
Извлекает информацию о временной брони для указанного места и дня из базы данных, возвращая информацию о текущем и оригинальном пользователях.

**Логика работы**:
1. **Создание соединения с базой данных**:
	- `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.
	- `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

2. **Извлечение информации о временной брони**:
	- Выполняется запрос к таблице temp_bookings для извлечения user (текущий пользователь) и original_user (оригинальный пользователь) для указанного места и дня:
	    - `cursor.execute("SELECT user, original_user FROM temp_bookings WHERE place = ? AND day = ?", (place, day))`
		- `result = cursor.fetchone()` получает результат запроса.

3. **Обработка результата**:
	- Если результат существует, функция извлекает user и original_user, и возвращает их в виде словаря:
		- `if result:`
    	- `user, original_user = result`
    	- `return {'user': user, 'original_user': original_user}`
	- Если результата нет, возвращается пустой словарь:
		 - `else:`
    	 - `return {}`

4. **Закрытие соединения**:
	- `connection.close()` закрывает соединение с базой данных в блоке finally, что гарантирует его закрытие даже в случае ошибки.

## get_temp_booked_places
Проверяет наличие временной брони для указанного места и дня. Если временная бронь не найдена, она проверяет наличие перманентной брони и возвращает соответствующую информацию.

**Логика работы**:
1. **Создание соединения с базой данных**:
	- `connection = sqlite3.connect('database.db')` устанавливает соединение с базой данных.
	- `cursor = connection.cursor()` создает объект курсора для выполнения SQL-запросов.

2. **Проверка временной брони**:
	- Выполняется запрос к таблице temp_bookings для получения пользователя, который временно забронировал место:
		- `cursor.execute("SELECT user FROM temp_bookings WHERE place = ? AND day = ?", (place, day))`
		- `temp_user = cursor.fetchone()` получает результат запроса.

3. **Обработка временной брони**:
	- Если временная броня существует (if temp_user:), соединение закрывается, и функция возвращает имя временного пользователя и значение True:
		- `connection.close()`
		- `return temp_user[0], True`

4. **Проверка перманентной брони**:
	- Если временной брони нет, выполняется запрос к таблице bookings для получения пользователя с перманентной броней:
		- `cursor.execute("SELECT user FROM bookings WHERE place = ? AND day = ?", (place, day))`
		- `perm_user = cursor.fetchone()` получает результат запроса.

5. **Обработка перманентной брони**:
	- После закрытия соединения (connection.close()), если перманентная броня существует (if perm_user:), функция возвращает имя пользователя и значение False, указывая, что это перманентная броня:
		- `return perm_user[0], False`
        
6. **Возврат значений**:
	- Если ни временной, ни перманентной брони не существует, функция возвращает None и False:
		- `return None, False`

